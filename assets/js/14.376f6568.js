(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{551:function(s,t,a){"use strict";a.r(t);var n=a(6),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h3",{attrs:{id:"标记清除-目前主流浏览器的做法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#标记清除-目前主流浏览器的做法"}},[s._v("#")]),s._v(" 标记清除（目前主流浏览器的做法）")]),s._v(" "),a("p",[s._v("简单点来说，就是清除上下文标记的没用的变量。")]),s._v(" "),a("blockquote",[a("p",[s._v("当变量进入上下文，比如在函数 内部声明一个变量时，这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永 远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时， 5 也会被加上离开上下文的标记。")])]),s._v(" "),a("h3",{attrs:{id:"引用计数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用计数"}},[s._v("#")]),s._v(" 引用计数")]),s._v(" "),a("p",[s._v("对每个值记录它被引用的次数。\n举例：当一个变量被引用时，记录这个变量的引用数+1，如果保存改变量的值被其他值覆盖了，记录这个变量的引用数-1。当一个值的引用数为 0 时，意味着无法访问这个值了，因此可以安全地收回其内存了。")]),s._v(" "),a("blockquote",[a("p",[s._v("缺点：无法解决循环引用的场景")])]),s._v(" "),a("p",[s._v("例如：")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("fn")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n\n  a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("foo "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("bar "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br")])]),a("p",[s._v("上述的例子中，a 与 b 通过各自的属性互相引用，意味着引用计数为 2，不会进行内存回收。在标记清除的策略下，不是问题。因为在函数执行之后，a 和 b 上下文都不存在了")])])}),[],!1,null,null,null);t.default=e.exports}}]);